> 2021.2.17准备面试，复习内容
## 1. JavaScript基础
### 1. call、apply、bind 的区别
>1.bind()作用：创建一个新的函数，在 bind() 被调用时，这个新函数的 this 被指定为 bind() 的第一个参数，而其余参数将作为新函数的参数，供调用时使用。   
2.call()作用：可以指定函数内部this的指向，传入多个参数，然后再调用该函数。   
3.apply() 方法调用一个函数, 其具有一个指定的this值，以及作为一个数组（或类似数组的对象）提供的参数
```
var name = "windowsName";
var a = {
    name: "Cherry",
    fn : function (params1, params2) {
        console.log(`${this.name}  ${params1}  ${params2}`);      // undefined
    }
}
var b = {
    name: "CherryB",
}
console.log("-------- bind ---------");
//作用：创建一个新的函数，在 bind() 被调用时，这个新函数的 this 被指定为 bind() 的第一个参数，而其余参数将作为新函数的参数，供调用时使用。
a.fn.bind(b, "params1", "params2")();

console.log("-------- call ---------");
//作用：可以指定函数内部this的指向，传入多个参数，然后再调用该函数。
a.fn.call(b, "params1", "params2");

console.log("-------- apply ---------");
// apply() 方法调用一个函数, 其具有一个指定的this值，以及作为一个数组（或类似数组的对象）提供的参数
a.fn.apply(b, ["params12", "params22"]);

输出：
-------- bind ---------
CherryB  params1  params2
-------- call ---------
CherryB  params1  params2
-------- apply ---------
CherryB  params12  params22
```

### 2. == 、===与object.is的区别
es5比较两个值是否相等：相等运算符（==）和严格相等运算符（===）。

缺点:  
==:自动转换数据类型，  
===: NaN不等于自身，以及+0等于-0。  
es6新的方法Object.is来比较两个值严格相等，它与严格比较运算符（===）基本一致，不同之处只有两个：一是+0不等于-0，二是NaN等于自身。

```
"" == false:  true
Object.is('xixi','xixi'):  true
Object.is({}, {}):  false
+0 === -0:  true
NaN === NaN:  false
Object.is(+0, -0):  false
Object.is(NaN, NaN):  true
```
### 3. [promise](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise) await 的作用
1. Promise 是一个对象，有三种状态`：pending，resolved，rejected`, 构建Promise的方式：
    ```
    new Promise( function(resolve, reject) {...} /* executor */  );
    ```
    Promise的构造函数里直接传入了一个function，我们可以称呼它为executor，它有两个函数参数resolve，reject。 **当上面这行语句执行的时候，executor会立即异步执行** 。在executor方法的方法体内，你可以写你自己的代码逻辑，一般逻辑代码都包括正常执行逻辑和出错异常处理，你可以在代码的正常执行逻辑里调用resolve（retValue）来把Promise的status改为resolved，在出错异常处理的代码里调用reject（err）来把Promise的status改为rejected。也就是说，executor函数的执行成功还是失败，是可以从Promise的状态里判断出来的。这里要注意两点:  
    * Promise从pending状态改为resolved或rejected状态只会有一次，一旦变成resolve或rejected之后，这个Promise的状态就再也不会改变了。   
    * 通过resolve(retValue)传入的retValue可以是任何值，null也可以，它会传递给后面的then方法里的function去使用。通过rejected（err）传入的err理论上也是没有限制类型的，但我们一般都会传入一个Error，比如reject(new Error(“Error”))    

    因为 Promise.prototype.then 和  Promise.prototype.catch的作用是Promise的状态改变的时候的回调函数

2. Promise链式调用
    ```
        let p = new Promise((resolve,reject) => {
            reject('reject');
        });

        let resultP = p.then(null,result => {
            console.log(result);
        });

        console.log(resultP);
    ```
    输出：  
    `Promise { <pending> }`  
    `reject`  
    js的执行顺序就是这样，同步->异步->回调，在同步执行的时候，Promise对象还处于pending的状态，也说明了这个then返回的是一个Promise对象。

3. [Promise.resolve()](https://www.jianshu.com/p/fe0159f8beb4)  
    返回一个状态`由给定value决定的Promise对象`。如果该值是thenable(即，带有then方法的对象)，返回的Promise对象的最终状态由then方法执行决定；否则的话(该value为空，基本类型或者不带then方法的对象),返回的Promise对象状态为fulfilled，并且将该value传递给对应的then方法。通常而言，如果您不知道一个值是否是Promise对象，使用Promise.resolve(value) 来返回一个Promise对象,这样就能将该value以Promise对象形式使用。

4. Promise.reject()  
    返回一个状态为失败的Promise对象，并将给定的失败信息传递给对应的处理方法

5. Async-Await的目的为了简化使用基于promise的API时所需的语法 
    1. async用于申明一个function是异步的，而await可以认为是async wait的简写，等待一个异步方法执行完成。
    2. await 的执行上下文必须是async函数，如果你在async函数体之外使用它，就会抛出语法错误
    3. await 表示在这里等待Promise返回结果后，再继续执行
    4. await 后面跟着的应该是一个Promise对象   
    使用示例：
    ```
        let testAwaitAsync = function () {
            function sleep(wait) {
                return new Promise((res,rej) => {
                    console.log(`cur wait t: ${wait}`);
                    setTimeout(() => {
                        res(wait);
                    },wait);
                });
            }
            async function demo() {
                let result01 = await sleep(100);
                //上一个await执行之后才会执行下一句
                let result02 = await sleep(result01 + 100);
                let result03 = await sleep(result02 + 100);
                // console.log(result03);
                return result03;
            }

            demo().then(result => {
                console.log(`result: ${result}`);
            });
        }
    ```
    输出：  
    cur wait t: 100   
    cur wait t: 200   
    cur wait t: 300  
    result: 300

6. Async-Await的错误处理  
    如果是reject状态，可以用try-catch捕捉
    ```
        let p = new Promise((resolve,reject) => {
            setTimeout(() => {
                reject('error');
            },1000);
        });
        async function demo(params) {
            try {
                let result = await p;
            }catch(e) {
                console.log(e);
            }
        }
        demo();
    ```
    输出：   
    error

### 3.[原型链](https://github.com/mqyqingfeng/Blog/issues/2)
![](https://github.com/ItsSecrets/DailyNote/blob/master/image/%E5%8E%9F%E5%9E%8B%E9%93%BE.png?raw=true)
```
    let testPrototype = function () {
        function Person() {
        }
        var person = new Person();
        console.log(`Person.__proto__ == Function.prototype: ${Person.__proto__ == Function.prototype}`) // true
        console.log(`Function.prototype.__proto__ == Object.prototype: ${Function.prototype.__proto__ == Object.prototype}`) // true
        console.log(`person.__proto__ == Person.prototype: ${person.__proto__ == Person.prototype}`) // true
        console.log(`Person.prototype.constructor == Person: ${Person.prototype.constructor == Person}`) // true
        // 顺便学习一个ES5的方法,可以获得对象的原型
        console.log(`Object.getPrototypeOf(person) === Person.prototype: ${Object.getPrototypeOf(person) === Person.prototype}`) // true
        console.log(`Person.prototype.__proto__ === Object.prototype: ${Person.prototype.__proto__ === Object.prototype}`) // true
        console.log(`Object.prototype.__proto__ === null: ${Object.prototype.__proto__ === null}`) // true
    }
    testPrototype()
```
    输出:   
    Person.__proto__ == Function.prototype: true
    Function.prototype.__proto__ == Object.prototype: true
    person.__proto__ == Person.prototype: true
    Person.prototype.constructor == Person: true
    Object.getPrototypeOf(person) === Person.prototype: true
    Person.prototype.__proto__ === Object.prototype: true
    Object.prototype.__proto__ === null: true    

### 4. [垃圾回收(标记-擦除、引用计数)](https://mp.weixin.qq.com/s/EuJzQajlU8rpZprWkXbJVg)
> 参考[链接](https://segmentfault.com/a/1190000018605776)
>1. 栈内存（Stack memory） 一片连续内存，存放临时变量
>2. 堆内存（Heap memory）动态不连续的内存，new出来的对象一般都放在堆上  
>3. 可达性（Reachability）  
>* 在 JavaScript 中，可达性指的是一个变量是否能够直接或间接通过全局对象访问到，如果可以那么该变量就是可达的（Reachable），否则就是不可达的（Unreachable）。

>![可达与不可达](https://github.com/ItsSecrets/DailyNote/blob/master/image/%E5%8F%AF%E8%BE%BE%E4%B8%8E%E4%B8%8D%E5%8F%AF%E8%BE%BE.png?raw=true)   

>   上图中的节点 9 和节点 10 均无法通过节点 1（根节点）直接或间接访问，所以它们都是不可达的，可以被安全地回收。

>4. 内存泄漏（Memory leak）  
>* 内存泄露指的是程序运行时由于某种原因未能释放那些不再使用的内存，造成内存空间的浪费。
轻微的内存泄漏或许不太会对程序造成什么影响，但是一旦泄露变严重，就会开始影响程序的性能，甚至导致程序的崩溃。
1. 标记-清除算法 Mark-Sweep GC
>    标记清除算法是目前最常用的垃圾收集算法之一。  
>    从该算法的名字上就可以看出，算法的关键就是标记与清除。  
>    标记指的是标记变量的状态的过程，标记变量的具体方法有很多种，但是基本理念是相似的。  
>    对于标记算法我们不需要知道所有细节，只需明白标记的基本原理即可。  
>    需要注意的是，这个算法的效率不算高，同时会引起内存碎片化的问题。         

    当一个变量进入执行上下文时，它就会被标记为“处于上下文中”；而当变量离开执行上下文时，则会被标记为“已离开上下文”。
    垃圾回收器将定期扫描内存中的所有变量，将处于上下文中以及被处于上下文中的变量引用的变量的标记去除，将其余变量标记为“待删除”。
    随后，垃圾回收器会清除所有带有“待删除”标记的变量，并释放它们所占用的内存。
    分为两个阶段：
    标记阶段：从根集合出发，将所有活动对象及其子对象打上标记
    清除阶段：遍历堆，将非活动对象（未打上标记）的连接到空闲链表上

>    优点
>*    实现简单， 容易和其他算法组合

>    缺点
>*    碎片化， 会导致无数小分块散落在堆的各处
>*    分配速度不理想，每次分配都需要遍历空闲列表找到足够大的分块
>*    与写时复制技术不兼容，因为每次都会在活动对象上打上标记

2. 标记-压缩 Mark-Compact
    和“标记－清除”相似，不过在标记阶段后它将所有活动对象紧密的排在堆的一侧（压缩），消除了内存碎片， 不过压缩是需要花费计算成本的。如下图过程，标记后需要定位各个活动对象的新内存地址，然后再移动对象，总共搜索了3次堆。
![](https://github.com/ItsSecrets/DailyNote/blob/master/image/v8%E6%95%B4%E7%90%86%E9%98%B6%E6%AE%B5.png?raw=true)
>    优点  
>*    有效利用了堆，不会出现内存碎片 也不会像复制算法那样只能利用堆的一部分

>    缺点  
>*    压缩过程的开销，需要多次搜索堆

3. 引用计数 Reference Counting    
    引用计数，就是记录每个对象被引用的次数，每次新建对象、赋值引用和删除引用的同时更新计数器，如果计数器值为0则直接回收内存。 很明显，引用计数最大的优势是暂停时间短   

>    优点
>*    可即刻回收垃圾  
>*    最大暂停时间短  
>*    没有必要沿指针查找， 不要和标记-清除算法一样沿着根集合开始查找   

>  缺点  
>*    计数器的增减处理繁重  
>*    计数器需要占用很多位  
>*    实现繁琐复杂， 每个赋值操作都得替换成引用更新操作  
>*    循环引用无法回收  


### 5. [事件循环](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/7)

1. 任务队列
*   JS分为同步任务和异步任务
*   同步任务都在主线程上执行，形成一个执行栈
*   主线程之外，事件触发线程管理着一个任务队列，只要异步任务有了运行结果，就在任务队列之中放置一个事件。
*   一旦执行栈中的所有同步任务执行完毕（此时JS引擎空闲），系统就会读取任务队列，将可运行的异步任务添加到可执行栈中，开始执行。

2. 宏任务  
    (macro)task（又称之为宏任务），可以理解是`每次执行栈执行的代码就是一个宏任务`（包括每次从事件队列中获取一个事件回调并放到执行栈中执行）。(macro)task主要包含:
>* script(整体代码)、
>* setTimeout、
>* setInterval、
>* I/O、
>* UI交互事件、
>* postMessage、
>* MessageChannel、
>* setImmediate(Node.js 环境)

3. 微任务  
    microtask（又称为微任务），可以理解是在当前 task 执行结束后立即执行的任务。也就是说，在当前task任务后，下一个task之前，在渲染之前。  
    所以它的响应速度相比setTimeout（setTimeout是task）会更快，因为无需等渲染。也就是说，在某一个macrotask执行完后，就会将在它执行期间产生的所有microtask都执行完毕（在渲染前）。microtask主要包含：
>*   Promise.then、
>*   MutaionObserver、
>*   process.nextTick(Node.js 环境)

4. 运行机制  
    在事件循环中，每进行一次循环操作称为 tick，每一次 tick 的任务处理模型是比较复杂的，但关键步骤如下：
>*   执行一个宏任务（栈中没有就从事件队列中获取）
>*   执行过程中如果遇到微任务，就将它添加到微任务的任务队列中
>*   宏任务执行完毕后，立即执行当前微任务队列中的所有微任务（依次执行）
>*   当前宏任务执行完毕，开始检查渲染，然后GUI线程接管渲染
>*   渲染完毕后，JS线程继续接管，开始下一个宏任务（从事件队列中获取）

5. await做了什么，需要特别注意  
    从字面意思上看await就是等待，await 等待的是一个表达式，这个表达式的返回值可以是一个promise对象也可以是其他值。

    很多人以为await会一直等待之后的表达式执行完之后才会继续执行后面的代码，实际上await是一个让出线程的标志。await后面的表达式会先执行一遍，`将await后面的代码加入到microtask中`，然后就会跳出整个async函数来执行后面的代码。
```
async function async1() {
	console.log('async1 start');
	await async2();
	console.log('async1 end');
}
```
等价于, `console.log('async1 end');`被加入到`microtask`中了
```
async function async1() {
	console.log('async1 start');
	Promise.resolve(async2()).then(() => {
                console.log('async1 end');
        })
}
```

6. Promise的创建方法是普通函数，在调用栈直接执行.只有`then`和`catch`里面的函数会加入microtask中
```
let promise2 = new Promise((resolve) => {
    resolve('promise2.then')
    console.log('promise2')
})
promise2.then((res) => {
    console.log(res)
    Promise.resolve().then(() => {
        console.log('promise3')
    })
})

输出:
promise2
promise2.then
promise3
```

### 7. [TypeScript装饰器](https://www.tslang.cn/docs/handbook/decorators.html)
>装饰器是一种特殊类型的声明，它能够被附加到类声明，方法， 访问符，属性或参数上。装饰器使用 @expression 这种形式，expression 求值后必须为一个函数，它会在运行时被调用，被装饰的声明信息做为参数传入。

1.  类装饰器 
    类装饰器在类声明之前被声明（紧靠着类声明）。 类装饰器应用于类`构造函数`，可以用来监视，修改或替换类定义。  
    类装饰器表达式会在运行时当作函数被调用，类的`构造函数`作为其唯一的参数。  
    如果类装饰器返回一个值，它会使用提供的`构造函数`来替换类的声明。

2. 属性装饰器  
    属性装饰器声明在一个属性声明之前（紧靠着属性声明）。 属性装饰器不能用在声明文件中（.d.ts），或者任何外部上下文（比如 declare的类）里。  
    属性装饰器表达式会在运行时当作函数被调用，传入下列2个参数  
>*    对于静态成员来说是类的构造函数，对于实例成员是类的原型对象。  
>*    成员的名字。

使用 TypeScript 声明 [CCClass](http://docs.cocos.com/creator/manual/zh/scripting/typescript.html?h=%E8%A3%85%E9%A5%B0%E5%99%A8), 但为了编辑器能够正确解析 属性检查器 里显示的各类属性，我们还需要使用引擎内置的一些装饰器，来将普通的 class 声明成 CCClass。

### 8. 执行上下文
    1. 函数上下文
    在函数上下文中，我们用活动对象(activation object, AO)来表示变量对象。
    活动对象和变量对象其实是一个东西，只是变量对象是规范上的或者说是引擎实现上的，不可在 JavaScript 环境中访问，只有到当进入一个执行上下文中，这个执行上下文的变量对象才会被激活，所以才叫 activation object 呐，而只有被激活的变量对象，也就是活动对象上的各种属性才能被访问。
    活动对象是在进入函数上下文时刻被创建的，它通过函数的 arguments 属性初始化。arguments 属性值是 Arguments 对象。
    2. 执行过程
    执行上下文的代码会分成两个阶段进行处理：分析和执行，我们也可以叫做：
        1. 进入执行上下文
        2. 代码执行

    3. 进入执行上下文
        当进入执行上下文时，这时候还没有执行代码，
        变量对象会包括：
            1. 函数的所有形参 (如果是函数上下文)   
                由名称和对应值组成的一个变量对象的属性被创建
                没有实参，属性值设为 undefined
            2.函数声明
                由名称和对应值（函数对象(function-object)）组成一个变量对象的属性被创建
                如果变`量对象已经存在相同名称的属性`，则完全替换这个属性
            3.变量声明
                由名称和对应值（undefined）组成一个变量对象的属性被创建；
                如果变量名称跟已经声明的形式参数或函数相同，则变量声明不会干扰已经存在的这类属性
        需要注意的是，优先函数声明。形参会有属性
    参考：
```
let tests上下文 = function () {

    function foo() {
        console.log(a);
        var a = 1;
    }
    foo(); // undefined  var 会变量提升

    function foo1() {
        console.log(a);
        a = 1;
    }
    // foo1(); // ReferenceError: a is not defined  没有var不会变量提升

    function bar() {
        a = 1;
        console.log(a);
    }
    bar();  // 1

    console.log(foo2); //[Function: foo2]  var foo2 = 1的变量提升不起作用，函数变量提升优先
    foo2();   // foo2
    function foo2() {
        console.log("foo2");
    }
    var foo2 = 1
}
```


## 2. C++
    1.时间规划  2d

## 3. 引擎基础
    1.时间规划 具体跟着时间线走

## 4. 渲染
    1.时间规划 2d

## 5. 网络
> 参考链接[TCP/IP四层模型](https://www.cnblogs.com/BlueTzar/articles/811160.html?utm_source=wechat_session&utm_medium=social&utm_oi=795900275578777600)
    
    1.时间规划 2d

### 1.TCP报文首部
![IP报文首部](https://github.com/ItsSecrets/DailyNote/blob/master/image/TCPPackageHead.jpg?raw=true)
    
    1.源、目标端口号字段：占16比特。TCP协议通过使用"端口"来标识源端和目标端的应用进程。端口号可以使用0到65535之间的任何数字。在收到服务请求时，操作系统动态地为客户端的应用程序分配端口号。在服务器端，每种服务在"众所周知的端口"（Well-Know Port）为用户提供服务。
    2.顺序号字段：占32比特。用来标识从TCP源端向TCP目标端发送的数据字节流，它表示在这个报文段中的第一个数据字节。　　
    3.确认号字段：占32比特。只有ACK标志为1时，确认号字段才有效。它包含目标端所期望收到源端的下一个数据字节。　　
    4.头部长度字段：占4比特。给出头部占32比特的数目。没有任何选项字段的TCP头部长度为20字节；最多可以有60字节的TCP头部。　　
    5.标志位字段（U、A、P、R、S、F）：占6比特。各比特的含义如下：　　
        1.URG：紧急指针（urgent pointer）有效。　　
        2.ACK：确认序号有效。　　
        3.PSH：接收方应该尽快将这个报文段交给应用层。　　
        4.RST：重建连接。　　
        5.SYN：发起一个连接。　　
        6.FIN：释放一个连接。  
    6.窗口大小字段：占16比特。此字段用来进行流量控制。单位为字节数，这个值是本机期望一次接收的字节数。　　
    7.TCP校验和字段：占16比特。对整个TCP报文段，即TCP头部和TCP数据进行校验和计算，并由目标端进行验证。　　
    8.紧急指针字段：占16比特。它是一个偏移量，和序号字段中的值相加表示紧急数据最后一个字节的序号。　　
    9.选项字段：占32比特。可能包括"窗口扩大因子"、"时间戳"等选项。

### 2. IP报文首部
![IP报文首部](https://github.com/ItsSecrets/DailyNote/blob/master/image/IPPackageHead.jpg?raw=true)

    1.版本（Version）字段：占4比特。用来表明IP协议实现的版本号，当前一般为IPv4，即0100。　　
    2.报头长度（Internet Header Length，IHL）字段：占4比特。是头部占32比特的数字，包括可选项。普通IP数据报（没有任何选项），该字段的值是5，即160比特=20字节。此字段最大值为60字节。　　
    3.服务类型（Type of Service ，TOS）字段：占8比特。其中前3比特为优先权子字段（Precedence，现已被忽略）。第8比特保留未用。第4至第7比特分别代表延迟、吞吐量、可靠性和花费。当它们取值为1时分别代表要求最小时延、最大吞吐量、最高可靠性和最小费用。这4比特的服务类型中只能置其中1比特为1。可以全为0，若全为0则表示一般服务。服务类型字段声明了数据报被网络系统传输时可以被怎样处理。例如：TELNET协议可能要求有最小的延迟，FTP协议（数据）可能要求有最大吞吐量，SNMP协议可能要求有最高可靠性，NNTP（Network News Transfer Protocol，网络新闻传输协议）可能要求最小费用，而ICMP协议可能无特殊要求（4比特全为0）。实际上，大部分主机会忽略这个字段，但一些动态路由协议如OSPF（Open Shortest Path First Protocol）、IS-IS（Intermediate System to Intermediate System Protocol）可以根据这些字段的值进行路由决策。　
    4.总长度字段：占16比特。指明整个数据报的长度（以字节为单位）。最大长度为65535字节。　　
    5.标志字段：占16比特。用来唯一地标识主机发送的每一份数据报。通常每发一份报文，它的值会加1。　　
    6.标志位字段：占3比特。标志一份数据报是否要求分段。　　
    7.段偏移字段：占13比特。如果一份数据报要求分段的话，此字段指明该段偏移距原始数据报开始的位置。　　
    8.生存期（TTL：Time to Live）字段：占8比特。用来设置数据报最多可以经过的路由器数。由发送数据的源主机设置，通常为32、64、128等。每经过一个路由器，其值减1，直到0时该数据报被丢弃。　　
    9.协议字段：占8比特。指明IP层所封装的上层协议类型，如ICMP（1）、IGMP（2） 、TCP（6）、UDP（17）等。　　
    10.头部校验和字段：占16比特。内容是根据IP头部计算得到的校验和码。计算方法是：对头部中每个16比特进行二进制反码求和。（和ICMP、IGMP、TCP、UDP不同，IP不对头部后的数据进行校验）。　　
    11.源IP地址、目标IP地址字段：各占32比特。用来标明发送IP数据报文的源主机地址和接收IP报文的目标主机地址。　　
    12.可选项字段：占32比特。用来定义一些任选项：如记录路径、时间戳等。这些选项很少被使用，同时并不是所有主机和路由器都支持这些选项。可选项字段的长度必须是32比特的整数倍，如果不足，必须填充0以达到此长度要求。

### 3. TCP连接建立、释放时的握手过程　
#### 1. 三次 握手建立连接　
![三次握手](https://github.com/ItsSecrets/DailyNote/blob/master/image/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.jpeg?raw=true)

    TCP会话通过三次握手来初始化。三次握手的目标是使数据段的发送和接收同步。同时也向其他主机表明其一次可接收的数据量（窗口大小），并建立逻辑连接。这三次握手的过程可以简述如下：　　
>    1.源主机发送一个同步标志位（SYN）置1的TCP数据段。此段中同时标明初始序号（Initial Sequence Number，ISN）。ISN是一个随时间变化的随机值。   
2.目标主机发回确认数据段，此段中的同步标志位（SYN）同样被置1，且确认标志位（ACK）也置1，同时在确认序号字段表明目标主机期待收到源主机下一个数据段的序号（即表明前一个数据段已收到并且没有错误）。此外，此段中还包含目标主机的段初始序号。   
3.源主机再回送一个数据段，同样带有递增的发送序号和确认序号。　　
　　至此为止，TCP会话的三次握手完成。接下来，源主机和目标主机可以互相收发数据。

#### 2. 为什么要三次握手  
三次握手的目的是建立可靠的通信信道，说到通讯，简单来说就是数据的发送与接收，而三次握手最主要的目的就是双方确认自己与对方的发送与接收是正常的。

第一次握手：Client 什么都不能确认；Server 确认了对方发送正常，自己接收正常

第二次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：对方发送正常，自己接收正常

第三次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己发送、接收正常，对方发送、接收正常


#### 3. 四次挥手释放链接  
![三次握手](https://github.com/ItsSecrets/DailyNote/blob/master/image/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.jpeg?raw=true)

TCP连接是全双工的，因此每个方向都必须单独进行关闭。  
1.客户端A发送一个FIN，用来关闭客户A到服务器B的数据传送，并发送一个自己的ISN（u）  
2.服务器B收到这个FIN，它发回一个ACK，确认序号为收到的序号加1（u+1）。同时发送一个自己的ISN(v)  
3.服务器B关闭与客户端A的连接，发送一个FIN、ACK给客户端A，确认号为收到的序号加1（u+1），与上一次不变。同时发送一个自己的ISN（w）  
4.客户端A发送ACK报文确认，并将确认序号设置为收到序号加1（w+1），序列号就是上一次的确认号（u+1）

#### 4. 为什么要四次挥手
任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了TCP连接。

### 4.ARP地址解析协议工作原理
每台主机都有一个ARP列表，存放IP地址和MAC地址的对应关系。
当源主机向目标主机发送数据时，首先查看ARP列表中IP地址对应的目标主机的MAC地址，如果找到则直接发送数据；如果找不到，就向该网段中的所有主机发送ARP请求包，里面存放源IP地址，源MAC地址，目标IP地址。
当该网段中的所有主机收到该ARP响应包之后，首先查看目标ip地址是否与自己相匹配，如果不是则忽略，如果是，就将源ip地址和源MAC地址存放到自己的ARP列表中，然后将自己的MAC地址存放到ARP响应包中发送给源主机；
目标主机收到ARP响应包，则取出对应的IP和MAC地址存放到ARP列表中，并发送数据。若未收到则ARP查询失败。
广播ARP请求，单播ARP响应。

### 5.DNS域名系统工作原理
1.查询 浏览器、操作系统 缓存。
2.请求 本地域名服务器
3.本地域名服务器未命中缓存，其请求 根域名服务器。
4.根域名服务器返回所查询域的主域名服务器。（主域名、顶级域名，如com、cn）
5.本地域名服务器请求主域名服务器，获取该域名的 名称服务器（域名注册商的服务器）。
6.本地域名服务器向 名称服务器 请求 域名-IP 映射。
7.缓存解析结果


### 6. 算法

### 7. 疑难问题
    1.时间规划 2d

### 8. 简历