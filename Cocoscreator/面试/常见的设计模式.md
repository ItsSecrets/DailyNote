## 1. 观察者模式
### 1. 原理 
在对象间定义一种一对多的关系，以便在某对象发生改变时，与它存在依赖关系的所有对象都能收到通知并自动进行更新。

### 2. 使用场景
引擎中的`EventDispatcher`事件中心还在使用。 感觉和事件管理器类似，游戏中更多的使用事件管理器。比如刷新资产展示UI，当收到资产改变的消息，通知订阅者刷新，当前谁在界面上都能收到消息并作出刷新操作。

## 2. 代理模式

### 1. 原理

### 2. 使用场景
入口程序`AppDelegate`负责程序的初始化工作和处理待机时的事务。
`Application`负责跨平台的特性 

### 3.优缺点：
关于代理模式的优点：
-    职责清晰，真实的角色就是实现实际的业务逻辑，不用关心其他非本职责的事务，通过后期的代理完成一件完成事务，附带的结果就是编程简洁清晰。
-    代理对象可以在客户端和目标对象之间起到中介的作用，这样起到了的作用和保护了目标对象的作用。
-    高扩展性


## 3. 单例模式
### 1. 原理

### 2. 使用场景

### 3. 优缺点：
优点：
- 简单易用，限制一个类只有一个实例，可以降低创建多个对象可能会引起的内存问题的风险，包括内存泄漏、内存占用问题。

缺点：
- 单例模式因为提供了一个全局的访问点，你可以在程序的任何地方轻而易取地访问到，这本身就是一种高耦合的设计。一旦单例改变以后，其它模块都需要修改。
- 单例模式使得对象变成了全局的了,相当于全局变量了

## 4. 工厂模式

### 1. 原理

### 2. 使用场景
只用过简单工厂模式，一般配合单例模式和对象池使用。考虑瀑布流那种的滚动视图是不是也可以用工厂模式。

### 3. 优缺点

## 5. 中介者模式
### 1. 原理

### 2. 使用场景
`cc.Director` 其实就是一个中介者，集合了 `_scheduler` 、 `_compScheduler` 、 `_nodeActivator` 、 `_actionManager`。 通过Director这个中介类，减少了系统中单例的数目，同时也使得这些类获得了单例的属性

### 3. 优缺点
优点：
- 把多个同事对象的交互封装到一个中介者对象中，使得同事对象之间松散耦合，互不依赖
- 集中控制交互
- 多对多变成了一对多

缺点：
- 容易造成中介者对象变成巨无霸类，维护和修改变得更加困难