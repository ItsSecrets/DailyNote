[出处](https://learnopengl-cn.github.io/01%20Getting%20started/07%20Transformations/)
## 变换

### 向量
向量最基本的定义就是一个方向。或者更正式的说，向量有一个方向(Direction)和大小(Magnitude，也叫做强度或长度)。

### 向量与标量运算
    
### 向量取反

### 向量加减


### 长度


### 向量相乘
#### 点乘
1. 两个向量的点乘等于它们的数乘结果乘以两个向量之间夹角的余弦值。`v¯⋅k¯=||v¯||⋅||k¯||⋅cosθ`
2. 它们之间的夹角记作θ。想象如果v¯和k¯都是单位向量，它们的长度会等于1。这样公式会有效简化成：
`v¯⋅k¯=1⋅1⋅cosθ=cosθ`
3. 使用点乘可以很容易测试两个向量是否正交(Orthogonal)或平行（正交意味着两个向量互为直角）。
#### 叉乘
1. 叉乘只在3D空间中有定义，它需要两个`不平行向量作为输入`，生成一个`正交`于两个输入向量的第三个向量。如果输入的两个向量也是正交的，那么叉乘之后将会产生3个互相正交的向量。接下来的教程中这会非常有用。下面的图片展示了3D空间中叉乘的样子：
![](https://github.com/ItsSecrets/DailyNote/blob/master/image/vectors_crossproduct.png?raw=true)
2. 两个正交向量A和B叉积:
![](https://github.com/ItsSecrets/DailyNote/blob/master/image/%E5%90%91%E9%87%8F%E5%8F%89%E4%B9%98.png?raw=true)

## 矩阵
### 矩阵的加减

### 矩阵的加减


### 矩阵相乘
1. 条件
    1. 只有当`左侧矩阵的列数`与`右侧矩阵的行数`相等，两个矩阵才能相乘。
    2. 矩阵相乘不遵守交换律(Commutative)，也就是说A⋅B≠B⋅A。
2. 矩阵相乘的例子：
![](https://github.com/ItsSecrets/DailyNote/blob/master/image/%E7%9F%A9%E9%98%B5%E7%9B%B8%E4%B9%983*3.png?raw=true)

### 矩阵与向量相乘
我们用向量来表示位置，表示颜色，甚至是纹理坐标.向量其实就是一个N×1矩阵，N表示向量分量的个数（也叫N维(N-dimensional)向量）。如果我们有一个`M×N`矩阵，我们可以用这个矩阵乘以我们的`N×1`向量，`因为这个矩阵的列数等于向量的行数`，所以它们就能相乘。

#### 单位矩阵
在OpenGL中，由于某些原因我们通常使用4×4的变换矩阵，而其中最重要的原因就是大部分的向量都是4分量的。我们能想到的最简单的变换矩阵就是`单位矩阵(Identity Matrix)`。单位矩阵是一个除了对角线以外都是0的`N×N`矩阵。在下式中可以看到，这种变换矩阵使一个向量完全不变：
![](https://github.com/ItsSecrets/DailyNote/blob/master/image/%E5%8D%95%E4%BD%8D%E7%9F%A9%E9%98%B5%E7%9B%B8%E4%B9%98.png?raw=true)
向量看起来完全没变。从乘法法则来看就很容易理解来：第一个结果元素是矩阵的第一行的每个元素乘以向量的每个对应元素。因为每行的元素除了第一个都是0，可得：1⋅1+0⋅2+0⋅3+0⋅4=1，向量的其他3个元素同理。

#### 缩放
1. 对一个向量进行缩放(Scaling)就是对向量的长度进行缩放，而保持它的方向不变。由于我们进行的是2维或3维操作，我们可以分别定义一个有2或3个缩放变量的向量，每个变量缩放一个轴(x、y或z)。
2. 我们先来尝试缩放向量v¯=(3,2)。我们可以把向量沿着x轴缩放0.5，使它的宽度缩小为原来的二分之一；我们将沿着y轴把向量的高度缩放为原来的两倍。我们看看把向量缩放(0.5, 2)倍所获得的s¯是什么样的：
![](https://github.com/ItsSecrets/DailyNote/blob/master/image/%E7%BC%A9%E6%94%BE1.png?raw=true)

3. 缩放变量表示为(S1,S2,S3)我们可以为任意向量(x,y,z)定义一个缩放矩阵：
![](https://github.com/ItsSecrets/DailyNote/blob/master/image/%E7%BC%A9%E6%94%BE%E7%9F%A9%E9%98%B5.png?raw=true)
>注意，第四个缩放向量仍然是1，因为在3D空间中缩放w分量是无意义的。w分量另有其他用途，在后面我们会看到。

#### 位移
`位移(Translation)`是在原始向量的基础上加上另一个向量从而获得一个在不同位置的新向量的过程，从而在位移向量基础上`移动`了原始向量。

和缩放矩阵一样，在4×4矩阵上有几个特别的位置用来执行特定的操作，对于位移来说它们是第四列最上面的3个值。如果我们把位移向量表示为(Tx,Ty,Tz)，我们就能把位移矩阵定义为：
![](https://github.com/ItsSecrets/DailyNote/blob/master/image/%E4%BD%8D%E7%A7%BB%E7%9F%A9%E9%98%B5.png?raw=true)

#### 旋转
2D或3D空间中的旋转用角(Angle)来表示。角可以是角度制或弧度制的，周角是360角度或2 PI弧度。
>大多数旋转函数需要用弧度制的角，但幸运的是角度制的角也可以很容易地转化为弧度制的：
>* 弧度转角度：角度 = 弧度 * (180.0f / PI)
>* 角度转弧度：弧度 = 角度 * (PI / 180.0f)PI约等于3.14159265359。

1. 在3D空间中旋转需要定义一个角和一个旋转轴(Rotation Axis)。物体会沿着给定的旋转轴旋转特定角度。
![](https://github.com/ItsSecrets/DailyNote/blob/master/image/%E6%97%8B%E8%BD%AC.png?raw=true)

#### 矩阵的组合
使用矩阵进行变换的真正力量在于，根据矩阵之间的乘法，我们可以把多个变换组合到一个矩阵中。假设我们有一个顶点(x, y, z)，我们希望将其缩放2倍，然后位移(1, 2, 3)个单位。我们需要一个位移和缩放矩阵来完成这些变换。结果的变换矩阵看起来像这样：
![](https://github.com/ItsSecrets/DailyNote/blob/master/image/%E7%9F%A9%E9%98%B5%E7%BB%84%E5%90%881.png?raw=true)
注意，当矩阵相乘时我们`先写位移再写缩放变换`的。矩阵乘法是不遵守交换律的，这意味着它们的顺序很重要。当矩阵相乘时，在最右边的矩阵是第一个与向量相乘的，所以你应该从右向左读这个乘法。建议您在组合矩阵时，`先进行缩放操作，然后是旋转，最后才是位移，否则它们会（消极地）互相影响`。比如，如果你先位移再缩放，位移的向量也会同样被缩放（译注：比如向某方向移动2米，2米也许会被缩放成1米）！

用最终的变换矩阵左乘我们的向量会得到以下结果：
![](https://github.com/ItsSecrets/DailyNote/blob/master/image/%E7%9F%A9%E9%98%B5%E7%BB%84%E5%90%882.png?raw=true)
不错！向量先缩放2倍，然后位移了(1, 2, 3)个单位。